package model;
import java.util.ArrayList;

import javafx.scene.Node;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.GridPane;

public class CellGrid extends GridPane {

	private Cell[][] grid;
	
	// TODO: Jordan: change parameters 
	//       number of initially empty (resets grid)
	// 		 percentage of states to each other (resets)
	// 		 step delay
	// 		 size of cells
	// 		 have a percentage of satisfied cells (dynamically)	 

	private Cell[][] grid;
	
	// TODO: Jordan: change parameters 
	//       number of initially empty (resets grid)
	// 		 percentage of states to each other (resets)
	// 		 step delay
	// 		 size of cells
	// 		 have a percentage of satisfied cells (dynamically)	 

	public CellGrid(int rows, int cols) {
		if (rows <= 0 || cols <= 0) {
			throw new IllegalArgumentException("Cannot have 0 or less rows/cols");
		}
		grid = new Cell[rows][cols];
<<<<<<< HEAD
		// TODO: Jordan set row/column constraints. maybe
	}
	
	public void renderGrid(BorderPane root) {
		return grid;
||||||| merged common ancestors
		// set row/column constraints?
	}
	
	//added so that I can find an empty cell in the grid to update future value of in segregation model
	public Cell[][] getGrid(){
		return grid;
=======
		// TODO: Jordan set row/column constraints. maybe
>>>>>>> c5967ff9cc6e8926d45c0d8618f319da358ad1fc
	}

	// Need to change spacing in flowpane if shape is different than rectangle
	public void renderGrid(FlowPane cellPane) {
		// loop through 2d grid, render each cell. should have already set up state correctly, 
		// this just needs to display it.
		
		for(int i = 0; i < getNumRows(); i++) {
			for (int j = 0; j < getNumCols(); j++) {
				Cell currentCell = grid[i][j];
				Node updatedCell = currentCell.render();
				cellPane.getChildren().add(updatedCell);
				// Place node inside of root 
			}
		}	
	}
	
	// TODO: Jordan Not needed. backend will just call getNeighbors()
	private void setNeighbors(Cell cell) {
		// need this in case user updates cell row/col to illegal spot?
		if (!isValidLocation(cell)) {
			throw new IllegalArgumentException("Location not valid");
		}
<<<<<<< HEAD
		
		
||||||| merged common ancestors
=======
		ArrayList<Cell> neighbors = getNeighbors(cell);
		cell.setNeighbors(neighbors);
>>>>>>> c5967ff9cc6e8926d45c0d8618f319da358ad1fc
	}
<<<<<<< HEAD

	// Backend does this
	/*
	private void updateGrid() { 
		// touch each cell and figure out future state
		for (int i = 0; i < getNumRows(); i++) {
			for (int j = 0; j < getNumCols(); j++) {
				Cell currentCell = grid[i][j];
				setNeighbors(currentCell); //dont need to do this. calls getNeighbors() in backend
				// update future state based on simulation rules;
				// which is done in Simulation backend
			}
		}

		// loop and update each cell
//		for (int i = 0; i < getNumRows(); i++) {
//			for (int j = 0; j < getNumCols(); j++) {
//				Cell currentCell = grid[i][j];
//				updateCurrentState(currentCell);
//			}
		}
	//s}

//	private void setNeighbors(Cell cell) {
//		// need this in case user updates cell row/col to illegal spot
//		if (!isValidLocation(cell)) {
//			throw new IllegalArgumentException("Location not valid");
//		}
//		ArrayList<Cell> neighbors = getNeighbors(cell);
//		cell.setNeighbors(neighbors);
//	}

||||||| merged common ancestors

	public abstract void updateGrid(); //{
		// touch each cell and figure out future state 
//		for (int i = 0; i < getNumRows(); i++) {
//			for (int j = 0; j < getNumCols(); j++) {
//				Cell currentCell = grid[i][j];
//				setNeighbors(currentCell);
//				// update future state based on simulation rules;
//				// which is done in rules engine class? 
//			}
//		}
		
		// loop and update each cell
//		for (int i = 0; i < getNumRows(); i++) {
//			for (int j = 0; j < getNumCols(); j++) {
//				Cell currentCell = grid[i][j];
//				updateCurrentState(currentCell);
//			}
//		}
	//s}

//	private void setNeighbors(Cell cell) {
//		// need this in case user updates cell row/col to illegal spot
//		if (!isValidLocation(cell)) {
//			throw new IllegalArgumentException("Location not valid");
//		}
//		ArrayList<Cell> neighbors = getNeighbors(cell);
//		cell.setNeighbors(neighbors);
//	}

=======
	
>>>>>>> c5967ff9cc6e8926d45c0d8618f319da358ad1fc
	/**
<<<<<<< HEAD
	 * Add to this method if implementing new shape
	 * Returns the neighbors of a shape. May need to change
	 * row/column deltas based on definition of 'neighbor'
	 * (diagonals or not)
||||||| merged common ancestors
	 * Add to this method if implementing new shape
=======
	 * Returns the neighbors of a shape. May need to change
	 * row/column deltas based on definition of 'neighbor'
	 * (diagonals or not)
>>>>>>> c5967ff9cc6e8926d45c0d8618f319da358ad1fc
	 * 
	 * @param cell - the shape
	 * @return - ArrayList<Cell> of cell's neighbors
	 */
	protected ArrayList<Cell> getNeighbors(Cell cell) {
		ArrayList<Cell> neighbors = new ArrayList<>();
		int rowPos = cell.getRowPos();
		int colPos = cell.getColPos();
		for (int i = 0; i < cell.getRowDeltas().length; i++) {
			int newRowPos = rowPos + cell.getRowDeltas()[i];
			int newColPos = colPos + cell.getColDeltas()[i];
			if (isValidLocation(grid[newRowPos][newColPos])) {
				neighbors.add(grid[newRowPos][newColPos]);
			}
		}
		return neighbors;
	}
<<<<<<< HEAD
	
	public abstract void updateCell(Cell myCell);
	/* backend does this too
	private void updateCurrentState(Cell cell) {
		cell.setCurrentstate(cell.getFuturestate());
	}

	private void setFutureState(Cell cell, String futurestate) {
		cell.setFuturestate(futurestate);
	}
	*/
||||||| merged common ancestors
	
	public abstract void updateCell(Cell myCell);
=======
>>>>>>> c5967ff9cc6e8926d45c0d8618f319da358ad1fc

	/* backend does this too
	private void updateCurrentState(Cell cell) {
		cell.setCurrentstate(cell.getFuturestate());
	}

	private void setFutureState(Cell cell, String futurestate) {
		cell.setFuturestate(futurestate);
	}
	*/

	private boolean isValidLocation(Cell cell) {
		return 0 <= cell.getRowPos() && 0 <= cell.getColPos() && cell.getRowPos() < getNumRows()
				&& cell.getColPos() < getNumCols();
	}
	
	public Cell[][] getGrid() {
		return grid;
	}

	public int getNumRows() {
		return grid.length;
	}

	public int getNumCols() {
		return grid[0].length;
	}

}
